<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>æ€ªç‰©å¾©æ´»è¿½è¹¤</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="icon-192.png" />
  <style>
    body { font-family: sans-serif; margin: 10px; }
    h1 { text-align: center; }
    .controls { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 1em; justify-content: center; }
    .monster-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 10px; }
    .monster-card { border: 1px solid #ccc; border-radius: 10px; padding: 10px; background: #f9f9f9; }
    .log-item { display: flex; justify-content: space-between; align-items: center; margin-top: 5px; padding: 5px; border-bottom: 1px solid #ddd; }
    .alarm { color: red; font-weight: bold; margin-left: 5px; }
    button { cursor: pointer; }
    .countdown { margin-left: 10px; color: #555; font-size: 0.9em; }
  </style>
</head>
<body>
  <h1>æ€ªç‰©å¾©æ´»è¿½è¹¤</h1>

  <div class="controls">
    <button onclick="exportJSON()">åŒ¯å‡º JSON</button>
    <button onclick="exportExcel()">åŒ¯å‡º Excel</button>
    <input type="file" id="importFile" accept=".json, .xlsx" onchange="handleImport(event)">
    <button onclick="syncToCloud()">åŒæ­¥åˆ°é›²ç«¯</button>
    <button onclick="loadFromCloud()">å¾é›²ç«¯è¼‰å…¥</button>
  </div>

  <div class="monster-grid" id="monsterGrid"></div>

  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js">

function syncToCloud() {
  fetch("https://script.google.com/macros/s/AKfycby3mYDtBDlL8ip0NzNA2B2sxRNbFhsBw4f2oFGkldMwG--51DEd-B81II384jl_rqOc/exec", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(logs)
  })
  .then(res => res.text())
  .then(txt => alert("âœ… åŒæ­¥æˆåŠŸï¼š" + txt))
  .catch(err => alert("âŒ åŒæ­¥å¤±æ•—ï¼š" + err));
}

function loadFromCloud() {
  fetch("https://script.google.com/macros/s/AKfycby3mYDtBDlL8ip0NzNA2B2sxRNbFhsBw4f2oFGkldMwG--51DEd-B81II384jl_rqOc/exec")
    .then(res => res.json())
    .then(data => {
      logs = data;
      saveLogs();
      alert("âœ… å¾é›²ç«¯è¼‰å…¥æˆåŠŸ");
    })
    .catch(err => alert("âŒ è¼‰å…¥å¤±æ•—ï¼š" + err));
}

</script>
  <script>
    const monsterData = [
      { name: "è‘›é›·é‡‘å‰›", minutes: [270, 350] },
      { name: "ä¹å°¾å¦–ç‹", minutes: [210, 570] },
      { name: "å·´æ´›å¤", minutes: [405, 540] },
      { name: "è‰¾åˆ©å‚‘", minutes: [118, 128] },
      { name: "é»‘è¼ªç‹map_7", minutes: [780, 1020] },
      { name: "é»‘è¼ªç‹map_7-1", minutes: [780, 1020] },
      { name: "é›ªæ¯›æ€ªäºº", minutes: [45, 68] },
      { name: "å„é‹æ­»ç¥", minutes: [45, 105] },
      { name: "ç´…å¯¶ç‹", minutes: [23, 30] },
      { name: "æ¨¹å¦–ç‹", minutes: [23, 30] },
      { name: "æ®­å±çŒ´ç‹", minutes: [38, 45] },
      { name: "åœ°éµå¹½éˆ", minutes: [45, 60] },
      { name: "æ²¼æ¾¤å·¨é±·", minutes: [90, 105] },
      { name: "è˜‘è‡ç‹", minutes: [210, 240] },
      { name: "æ®­å±è˜‘è‡ç‹", minutes: [195, 225] },
      { name: "å·¨å±…èŸ¹", minutes: [45, 60] },
      { name: "å’•å’•é˜", minutes: [68, 90] },
      { name: "ä»™äººå¨ƒå¨ƒ", minutes: [158, 180] },
      { name: "å–µæ€ªä»™äºº", minutes: [150, 170] },
      { name: "æ›¸ç”Ÿ", minutes: [150, 300] },
      { name: "å·¨å¤§æ·±å±±äººåƒ", minutes: [60, 135] },
      { name: "é›ªå±±é­”å¥³", minutes: [158, 180] },
      { name: "è‚¯çš„ç†Š", minutes: [113, 128] },
    ];

    let logs = JSON.parse(localStorage.getItem("logs") || "[]");

    function saveLogs() {
      localStorage.setItem("logs", JSON.stringify(logs));
      renderLogs();
    }

    function addLog(monster, channel) {
      const now = new Date();
      const existing = logs.find(l => l.monster === monster && l.channel === channel);
      if (existing) return;
      logs.push({ monster, channel: String(channel).trim(), timestamp: now.toISOString() });
      saveLogs();
    }

    function deleteLog(index) {
      logs.splice(index, 1);
      saveLogs();
    }

    function renderLogs() {
      document.getElementById("monsterGrid").innerHTML = monsterData.map(mon => {
        const displayName = `${mon.name}ï¼ˆ${mon.minutes[0]}-${mon.minutes[1]}åˆ†ï¼‰`;
        const entries = logs
          .map((log, i) => ({ ...log, i }))
          .filter(l => l.monster === mon.name)
          .map(l => {
            const dt = new Date(l.timestamp);
            const revive = new Date(dt.getTime() + mon.minutes[0] * 60000);
            const timeStr = revive.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const alarm = (revive - Date.now()) < 10 * 60 * 1000 ? 'â°' : '';
            const countdown = `<span class="countdown">(<span id="cd-${l.i}"></span>)</span>`;
            return `<div class="log-item">
              <span>${alarm} ${timeStr} | ${l.channel} ${countdown}</span>
              <button onclick="deleteLog(${l.i})">âŒ</button>
            </div>`;
          }).join("");

        return `<div class="monster-card">
          <div><strong>${displayName}</strong></div>
          <div>
            é »é“ï¼š<input id="ch-${mon.name}" placeholder="ex. CH1" />
            <button onclick="addLog('${mon.name}', document.getElementById('ch-${mon.name}').value)">ç™»è¨˜</button>
          </div>
          ${entries}
        </div>`;
      }).join("");

      updateCountdowns();
    }

    function updateCountdowns() {
      logs.forEach((log, i) => {
        const mon = monsterData.find(m => m.name === log.monster);
        if (!mon) return;
        const dt = new Date(log.timestamp);
        const revive = new Date(dt.getTime() + mon.minutes[0] * 60000);
        const msLeft = revive - Date.now();
        const cdElem = document.getElementById(`cd-${i}`);
        if (cdElem) {
          if (msLeft <= 0) {
            cdElem.textContent = "å·²å¾©æ´»";
          } else {
            const min = Math.floor(msLeft / 60000);
            const sec = Math.floor((msLeft % 60000) / 1000);
            cdElem.textContent = `${min}åˆ†${sec}ç§’`;
          }
        }
      });
      setTimeout(updateCountdowns, 1000);
    }

    function exportJSON() {
      const blob = new Blob([JSON.stringify(logs, null, 2)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "monster_logs.json";
      a.click();
    }

    function exportExcel() {
      const ws = XLSX.utils.json_to_sheet(logs);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Logs");
      XLSX.writeFile(wb, "monster_logs.xlsx");
    }

    function handleImport(e) {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = function(evt) {
        let newLogs = [];
        if (file.name.endsWith(".json")) {
          newLogs = JSON.parse(evt.target.result);
        } else {
          const wb = XLSX.read(evt.target.result, { type: "binary" });
          const sheet = wb.Sheets[wb.SheetNames[0]];
          newLogs = XLSX.utils.sheet_to_json(sheet);
        }
        const exists = new Set(logs.map(l => l.monster + l.channel + l.timestamp));
        newLogs.forEach(l => {
          const key = l.monster + l.channel + l.timestamp;
          if (!exists.has(key)) logs.push(l);
        });
        saveLogs();
      };
      if (file.name.endsWith(".json")) {
        reader.readAsText(file);
      } else {
        reader.readAsBinaryString(file);
      }
    }

    const SHEET_URL = "https://script.google.com/macros/s/AKfycby3mYDtBDlL8ip0NzNA2B2sxRNbFhsBw4f2oFGkldMwG--51DEd-B81II384jl_rqOc/exec";


    function syncToCloud() {
      if (!logs.length) {
        alert("âš  æ²’æœ‰ä»»ä½•è³‡æ–™å¯åŒæ­¥");
        return;
      }
      fetch(SHEET_URL, {
        method: "POST",
        body: JSON.stringify(logs),
        headers: { "Content-Type": "text/plain;charset=utf-8" }
      }).then(r => r.text()).then(t => {
        alert("âœ… é›²ç«¯å›æ‡‰ï¼š" + t);
      }).catch(err => {
        alert("âŒ é›²ç«¯åŒæ­¥å¤±æ•—ï¼š" + err.message);
      });
    }

    function loadFromCloud() {
      fetch(SHEET_URL)
        .then(r => r.json())
        .then(res => {
          if (res.status === 'ok' && Array.isArray(res.data)) {
            const exists = new Set(logs.map(l => l.monster + l.channel + l.timestamp));
            res.data.forEach(l => {
              const key = l.monster + l.channel + l.timestamp;
              if (!exists.has(key)) logs.push(l);
            });
            saveLogs();
            alert("âœ… é›²ç«¯è³‡æ–™è¼‰å…¥æˆåŠŸ");
          } else {
            alert("âš  é›²ç«¯è³‡æ–™æ ¼å¼éŒ¯èª¤");
          }
        })
        .catch(err => {
          console.error("é›²ç«¯è¼‰å…¥å¤±æ•—:", err);
          alert("âŒ è®€å–è³‡æ–™å¤±æ•—");
        });
    }

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js');
    }

        renderLogs();
    loadFromCloud();

    // âœ… è‡ªå‹•åµæ¸¬æ–°ç‰ˆä¸¦é‡æ–°è¼‰å…¥
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').then(reg => {
        reg.addEventListener('updatefound', () => {
          const newWorker = reg.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              console.log("ğŸ”„ åµæ¸¬åˆ°æ–°ç‰ˆæœ¬ï¼Œè‡ªå‹•é‡æ–°æ•´ç†");
              window.location.reload();
            }
          });
        });
      });
    }

	
  </script>
</body>
</html>
